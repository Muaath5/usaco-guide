---
id: parallel-binary-search
title: 'Parallel Binary Search'
author: Muaath Alqarni
description: 'Answering multiple binary search queries parallelly'
prerequisites:
  - binary-search
frequency: 0
---


## Resources

<Resources>
	<Resource source="CF" title="Parallel Binary Seach [tutorial]" url="45578" />
	<Resource source="SPBook" title="Parallel Binary Seach" url="https://kostka.dev/sp/spbook.pdf#page=22" />
</Resources>

<FocusProblem problem="sam" />

## Solution - New Roads Queries
Let's think about how to use binary to answer single query.
We can see that connvectivity of the nodes is a monotonic function.

Now let's use parallel binary search:

First, sort the queries by median.

Then sweep through the array of edges and union them in the DSU,
whenevery there is a query with median = $i$, if the two nodes where connected in DSU, it means the answer is $\leq i$, otherwise it means $\gt i$.

**Complexity:**

We need to do the sweep $O(\log_2{N})$ times, same as binary search.
Sorting the queries by median is $O(Q \cdot \log_2{Q})$
And $O(\alpha(N))$ for the DSU


Total Complexity: $O((N + Q) \cdot \log_2(N+Q)^2 \cdot \alpha(N))$

## Implementation - New Roads Queries
<LanguageSection>

<CPPSection>

```cpp
#include <bits/stdc++.h>
using namespace std;

const int N = 2e5 + 1;

struct DSU {
	int cnt[N], par[N];
	void Init(int sz) {
		for (int i = 0; i <= sz; i++) par[i] = i, cnt[i] = 1;
	}
	int Root(int node) {
		if (par[node] == node) return node;
		return Root(par[node]);
	}
	void Union(int x, int y) {
		x = Root(x), y = Root(y);
		if (cnt[x] < cnt[y]) swap(x, y);
		if (x == y) return;
		par[y] = x;
		cnt[x] += cnt[y];
	}
	bool Connected(int x, int y) { return Root(x) == Root(y); }
};

// Parallel Binary Search Query
struct PBS {
	// l, r are the binary search variables
	int idx, l, r;
	int a, b;
	int Mid() const { return (l + r) / 2; }
} qrs[N];

int main() {
	ios::sync_with_stdio(0), cin.tie(0);
	int n, m, q;
	cin >> n >> m >> q;

	vector<pair<int, int>> edges;
	for (int i = 0; i < m; i++) {
		int a, b;
		cin >> a >> b;
		edges.push_back({a, b});
	}

	for (int i = 0; i < q; i++) {
		cin >> qrs[i].a >> qrs[i].b;
		qrs[i].idx = i;
		qrs[i].l = 1, qrs[i].r = m + 1;
	}
	DSU dsu;
	int lg = ceil(log2(m + 2));
	while (lg--) {
		dsu.Init(n);
		sort(qrs, qrs + q,
		     [](const PBS &x, const PBS &y) { return x.Mid() < y.Mid(); });
		// Pointer of current query
		int idx = 0;
		for (int i = 0; i < m; i++) {
			dsu.Union(edges[i].first, edges[i].second);
			while (idx < q && qrs[idx].Mid() == i + 1) {
				// If the two nodes were connected after i edges
				if (dsu.Connected(qrs[idx].a, qrs[idx].b))
					// the answer will be <= i
					qrs[idx].r = qrs[idx].Mid();
				else
					// Otherwise, it needs more edges to be connected, the
					// answer will be > i
					qrs[idx].l = qrs[idx].Mid() + 1;
				idx++;
			}
			if (idx == q) break;
		}
	}

	sort(qrs, qrs + q,
	     [](const PBS &x, const PBS &y) { return x.idx < y.idx; });

	for (int i = 0; i < q; i++) {
		// if after union of all edges still not connected
		if (qrs[i].l == m + 1) cout << -1 << '\n';
		// if asking is the node connected to itself
		else if (qrs[i].a == qrs[i].b) cout << 0 << '\n';
		else cout << qrs[i].l << '\n';
	}
}
```

</CPPSection>

</LanguageSection>

## Problems

<Problems problems="gen" />
